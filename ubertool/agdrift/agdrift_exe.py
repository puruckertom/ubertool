from __future__ import divisionimport loggingimport numpy as npimport osimport pandas as pdimport scipy.interpolate as interpfrom scipy import integratefrom scipy.optimize import curve_fitimport sys#find parent directory and import model#parentddir = os.path.abspath(os.path.join(os.path.dirname(__file__), os.path.pardir))#sys.path.append(parentddir)from base.uber_model import UberModel, ModelSharedInputsfrom agdrift_functions import AgdriftFunctionsclass AgdriftInputs(ModelSharedInputs):    """    Input class for Agdrift.    """    def __init__(self):        """Class representing the inputs for TerrPlant"""        super(AgdriftInputs, self).__init__()        self.application_rate = pd.Series([], dtype="float")        self.application_method = pd.Series([], dtype="object")        self.drop_size = pd.Series([], dtype="object")        self.ecosystem_type = pd.Series([], dtype="object")        self.boom_height = pd.Series([], dtype="object")        self.airblast_type = pd.Series([], dtype="object")        self.aquatic_body_type = pd.Series([], dtype="object")        self.terrestrial_field_type = pd.Series([], dtype="object")        self.user_pond_width = pd.Series([], dtype="float")        self.user_pond_depth = pd.Series([], dtype="float")        self.user_wetland_width = pd.Series([], dtype="float")        self.user_wetland_depth = pd.Series([], dtype="float")        self.user_terrestrial_width = pd.Series([], dtype="float")        self.calculation_input = pd.Series([], dtype="object")        self.downwind_distance = pd.Series([], dtype="float")class AgdriftOutputs(object):    """    Output class for Agdrift.    """    def __init__(self):        """Class representing the outputs for Agdrift"""        super(AgdriftOutputs, self).__init__()        #self.out_nasae = pd.Series(name="out_nasae").astype("int")        self.out_sim_scenario_chk = pd.Series(name="out_sim_scenario_chk").astype("object")        self.out_sim_scenario_id = pd.Series(name="out_sim_scenario_id").astype("object")        self.out_interp_deposition = pd.Series(name="out_interp_deposition").astype("float")        #self.out_express_y = pd.Series(name="out_express_y").astype("object")        self.out_avg_dep_foa = pd.Series(name="out_avg_dep_foa").astype("float")        self.out_avg_dep_lbac = pd.Series(name="out_avg_dep_lbac").astype("float")        self.out_avg_dep_gha = pd.Series(name="out_avg_dep_gha").astype("float")        self.out_avg_waterconc_ngl = pd.Series(name="out_avg_waterconc_ngl").astype("float")        self.out_avg_field_dep_mgcm = pd.Series(name="out_avg_field_dep_mgcm").astype("float")class Agdrift(UberModel, AgdriftInputs, AgdriftOutputs, AgdriftFunctions):    """    Agdrift class to implement tier 1 air drift screening models.    """    def __init__(self, pd_obj, pd_obj_exp):        """Class representing the Agdrift model and containing all its methods"""        super(Agdrift, self).__init__()        self.pd_obj = pd_obj        self.pd_obj_exp = pd_obj_exp        self.pd_obj_out = None    def execute_model(self):        """        Callable to execute the running of the model:            1) Populate input parameters            2) Create output DataFrame to hold the model outputs            3) Run the model's methods to generate outputs            4) Fill the output DataFrame with the generated model outputs        """        self.populate_inputs(self.pd_obj)        self.pd_obj_out = self.populate_outputs()        self.run_methods()        self.fill_output_dataframe()        logging.info(self.pd_obj_out)        logging.info('executed agdrift')    def run_methods(self):        """        Controller method that runs all subroutines in sequence.        :return:        """        try:            self.set_global_constants()            # determine if scenario description data combine to form a valid scenario (i.e., one for which deposition data exists)            self.out_sim_scenario_chk = pd.Series([], dtype='object')            self.validate_sim_scenarios()            #pull column names from sql database ((these names reflect scenario types)            self.column_names = self.get_column_names()  #distance and scenario names as identified as database columns            self.num_scenarios = len(self.column_names) - 1 #-1 is to avoid counting the distance column as a scenario type            #assign column names to appropriate variables (i.e., the distance and scenario names)            self.assign_column_names()            # scan simulation input data and define scenario ids (to match column names from sql database)            self.set_sim_scenario_id()            #assign list of simulations per scenario            #this is so we can execute the interpolator function generator once per scenario type            self.num_scenario_sims, self.scenario_sim_indices = self.list_sims_per_scenario()            #pull distance array values from sql database (we assume array applies to all scenarios)            self.distances_temp = self.get_distances(self.num_db_values)            #populate output variable arrays with default values            self.out_interp_deposition = pd.Series(self.num_simulations*['nan'], dtype='float')            self.out_avg_dep_foa = pd.Series(self.num_simulations*['nan'], dtype='float')            self.out_avg_dep_lbac = pd.Series(self.num_simulations*['nan'], dtype='float')            self.out_avg_dep_gha = pd.Series(self.num_simulations*['nan'], dtype='float')            self.out_avg_waterconc_ngl = pd.Series(self.num_simulations*['nan'], dtype='float')            self.out_avg_field_dep_mgcm = pd.Series(self.num_simulations*['nan'], dtype='float')            #initialize internal variables            self.scenario_raw_data = pd.Series(self.num_scenarios*[[]], dtype='float')            self.scenario_distance_data = pd.Series(self.num_scenarios*[[]], dtype='float')            self.scenario_deposition_data = pd.Series(self.num_scenarios*[[]], dtype='float')            self.scenario_interp_func = pd.Series(self.num_scenarios*['NoFunction'], dtype='object')            # load, process/filter, and create interpolation function for deposition data            for i in range(self.num_scenarios):                if (self.num_scenario_sims[i] > 0):  #only get data if scenario is included in 1 or more simulations                    self.scenario_raw_data[i] = self.get_scenario_deposition_data(self.scenario_name[i], self.num_db_values)                    # process raw data to remove blank values from distance and deposition arrays                    self.scenario_distance_data[i], self.scenario_deposition_data[i] = \                        self.filter_arrays(self.distances_temp, self.scenario_raw_data[i])  #always send in the original distance_temp array                    #fit last 16 data points to an exponential of form y = A*exp(Bx) (to allow extrapolation)                    npts_tot = len(self.scenario_distance_data[i])                    npts_fit = npts_tot - 16                    ##############                    #the following code will be placed in a method and called                    ##############                    #set arrays for containing curve points to be used to fit/extend curve at tail                    x_array = np.zeros([16])                    y_array = np.zeros([16])                    #select that last 16 data points and perform a straight natural log transform on the distance/deposition values                    #then fit these data to a line of best fit                    x_array =  np.array([self.scenario_distance_data[i][j] for j in range(npts_fit,npts_tot)])                    x_array = np.log(x_array)                    y_array =  np.array([self.scenario_deposition_data[i][j] for j in range(npts_fit,npts_tot)])                    y_array = np.log(y_array)                    #the following log transformations are what's found in the AGDRIFT AGEXTD code                    # x_zero = self.scenario_distance_data[i][npts_fit-1]                    # y_zero = self.scenario_deposition_data[i][npts_fit-1]                    # y_zero_log = np.log(y_zero)                    #                    # k=0                    # for j in range (npts_fit, npts_tot):                    #     x_array[k] = np.log(self.scenario_distance_data[i][j] - x_zero)                    #     y_array[k] = np.log(self.scenario_deposition_data[i][j]/y_zero)                    #     k+=1                    #establish scipy function to be fit to x_array, y_array data pts                    def func(x_array,a,b):                        return a*x_array + b                    #return a * np.exp(-b * x_array) + c                    #use scipy's curve fit and get the coefficients for the established function                    popt, pcov = curve_fit(func, x_array, y_array)                    coef_a = popt[0]                    coef_b = popt[1]                    #extend the distance and deposition arrays to 2 * 997 = 1994ft in increments of 6.56ft                    npts_orig = len(self.scenario_distance_data[i])                    npts_ext = int(((((self.max_distance * 2.)  - self.scenario_distance_data[i][npts_orig-1]) / \                                       self.distance_inc) + 1) + npts_orig)                    dist = self.scenario_distance_data[i][npts_orig-1]                    k=0                    for j in range (npts_orig, npts_ext):                        dist = dist + self.distance_inc                        # y_temp = coef_a * np.log(dist - x_zero) + coef_b                        # self.scenario_deposition_data[ i][j] = np.exp(y_temp + y_zero_log)                        self.scenario_deposition_data[i][j] = np.exp(coef_a * np.log(dist) + coef_b)                        self.scenario_distance_data[i][j] = self.scenario_distance_data[i][j-1] + self.distance_inc                        k+=1                    # establish functions for deposition curve to facilitate interpolation and integration                    self.scenario_interp_func[i] = interp.interp1d(self.scenario_distance_data[i],                                                        self.scenario_deposition_data[i], kind=self.interpolator)            #loop through simulations calculating necessary interopolations/integrations and units conversions            for i in range(self.num_simulations):                if ('Invalid' not in self.out_sim_scenario_chk[i]):  #process only valid simulation scenarios                    #locate index of scenario that applies to this simulation                    for j in range (self.num_scenarios):                        if (self.out_sim_scenario_id[i] == self.scenario_name[j]):                            scenario_index = j                    interp_deposition = avg_dep_foa = avg_dep_lbac = avg_dep_gha = avg_waterconc_ngl = avg_field_dep_mgcm = float('nan')                    #determine area/length/depth of area of concern                    area_width, area_length, area_depth = self.determine_area_dimensions(i)                    #set distance from edge of application area to user specified initial point of interest                    downwind_distance_short = self.downwind_distance[i]                    # call interpolation function for downwind distance short                    interp_deposition = self.scenario_interp_func[scenario_index](downwind_distance_short)                    #perform integration across areas and calculate relevant average water concentrations and aerial deposition rates                    if (self.ecosystem_type[i] == 'Aquatic Assessment' or (self.ecosystem_type[i] ==                        'Terrestrial Assessment' and self.terrestrial_field_type[i] == 'User Defined Terrestrial')):                        # set distance value to downwind side of area for which  integration is needed                        downwind_distance_long = downwind_distance_short + area_width                        #check if distance (from edge of application area) to upwind edge of waterbody is <= 997 and that                        #area_width >= 6.56 & <= 997                        #if these condictions are not met then invalidate this simulation (997 is the furthest distance for which deposition data is available)                        if(downwind_distance_short <= self.max_distance and area_width <= self.max_distance and  \                                   area_width >= self.min_area_width):                            # integrate over distance from nearest to furthest downwind points of pond/wetland/field)                            integration_result = integrate.romberg(self.scenario_interp_func[scenario_index],                                                                          downwind_distance_short, downwind_distance_long)                            # calculate output variables                            avg_dep_foa = self.calc_avg_dep_foa(integration_result, area_width)                            avg_dep_lbac = self.calc_avg_dep_lbac(avg_dep_foa, self.application_rate[i])                            avg_dep_gha = self.calc_avg_dep_gha(avg_dep_lbac)                            #calculate water concentration for waterbody or area avg deposition rate for terrestrial area                            if (self.ecosystem_type[i] == 'Aquatic Assessment'):                                avg_waterconc_ngl = self.calc_avg_waterconc_ngl(avg_dep_lbac,                                                                        area_width, area_length, area_depth)                            elif (self.ecosystem_type[i] == 'Terrestrial Assessment'):                                avg_field_dep_mgcm = self.calc_avg_fielddep_mgcm(avg_dep_lbac)                        else:                            #set simulation check variable to invalid                            self.out_sim_scenario_chk[i] = self.out_sim_scenario_chk[i].replace('Valid', 'Invalid')  \                                                           + ' Due to Distance Violation'                    elif (self.ecosystem_type[i] == 'Terrestrial Assessment' and                          self.terrestrial_field_type[i] == 'EPA Defined Terrestrial'):                        #just interested in point deposition (no integration)                        # calculate output variables                        avg_dep_foa = interp_deposition  #simply the fraction of applied deposition value at the point of intesest                        avg_dep_lbac = self.calc_avg_dep_lbac(avg_dep_foa, self.application_rate[i])                        avg_dep_gha = self.calc_avg_dep_gha(avg_dep_lbac)                        avg_field_dep_mgcm = self.calc_avg_fielddep_mgcm(avg_dep_lbac)                if self.round:                    # round output variable values (and place in output variable series) so that they can be directly                    # compared to expected results (which were limited in terms of their output format from the OPP AGDRIFT                    # model interface (we don't have the AGDRIFT code so we cannot change the output format to                    # agree with this model                    if (interp_deposition > 1e-4):                        self.out_interp_deposition[i] = round(interp_deposition, 4)                    else:                        self.out_interp_deposition[i] = interp_deposition                    if (avg_dep_foa > 1e-4):                        self.out_avg_dep_foa[i] = round(avg_dep_foa, 4)                    else:                        self.out_avg_dep_foa[i] = avg_dep_foa                    if (avg_dep_lbac > 1e-4):                        self.out_avg_dep_lbac[i] = round(avg_dep_lbac, 4)                    else:                        self.out_avg_dep_lbac[i] = avg_dep_lbac                    if (avg_dep_gha > 1e-4):                        self.out_avg_dep_gha[i] = round(avg_dep_gha, 4)                    else:                        self.out_avg_dep_gha[i] = avg_dep_gha                    if (avg_waterconc_ngl > 1e-4):                        self.out_avg_waterconc_ngl[i] = round(avg_waterconc_ngl, 4)                    else:                        self.out_avg_waterconc_ngl[i] = avg_waterconc_ngl                    if (avg_field_dep_mgcm > 1e-4):                        self.out_avg_field_dep_mgcm[i] = round(avg_field_dep_mgcm, 4)                    else:                        self.out_avg_field_dep_mgcm[i] = avg_field_dep_mgcm                else:                    self.out_interp_deposition[i] = interp_deposition                    self.out_avg_dep_foa[i] = avg_dep_foa                    self.out_avg_dep_lbac[i] = avg_dep_lbac                    self.out_avg_dep_gha[i] = avg_dep_gha                    self.out_avg_waterconc_ngl[i] = avg_waterconc_ngl                    self.out_avg_field_dep_mgcm[i] = avg_field_dep_mgcm        except:            pass    def set_global_constants(self):        #set scenario database name, table name, and number of data points (all scenarios have equal number of data points)        self.db_name = 'sqlite:///sqlite_agdrift_distance.db'        self.db_table = 'output'        self.num_db_values = 161        #set interpolation method for runs        self.interpolator = 'linear'        #self.interpolator = 'quadratic'        #self.interpolator = 'cubic'        #set whether to round output values        #self.round = False        self.round = True        #set rounding degree        self.round_to = 1e-4        #set number of model run simulations to be performed (equal to the number of entries in any one of the input variables)        #used throughout code to specify number of times a piece of code should be executed (e.g., for loops)        self.num_simulations = len(self.application_rate)        #set standard width and length for ponds/wetlands/terrestrial fields        self.default_width = 208.7  #feet of width of EPA Defined Pond or Wetland        self.default_length = 515.8 #feet of length of EPA Defined Pond or Wetland        #set standard depth for ponds and wetlands        # 2.0 m = 6.56168 feet        self.default_pond_depth = 6.56       #feet        self.default_wetland_depth = 0.4921  #feet        self.max_distance = 997.   #feet (this applies to both area_width and downwind distance to leading edge of pond/wetland/terrestrial area        self.distance_inc = 6.56   #feet        self.min_area_width = 6.56  #feet : incremental distance between points in deposition data        #agdrift source code        #'  conversion factors        #Public Const UN_INCHESPERMETER = 39.37     'in/m        small length        #Public Const UN_CMPERMETER = 100           'cm/m        small length        #Public Const UN_FEETPERMETER = 3.2808      'ft/m        length        #Public Const UN_FEET2PERMETER2 = 10.7636   'ft2/m2      area        #Public Const UN_ACRESPERHECTARE = 2.471    'ac/ha       arealarge        #Public Const UN_GALLONSPERLITER = 0.2642   'gal/L       volume        #Public Const UN_MPSPERMPH = 0.44704        '(m/s)/(mph) speed        #Public Const UN_POUNDSPERKILOGRAM = 2.2055 'kg/lb       mass        #Public Const UN_PSIPERBAR = 14.5038        'psi/bar     pressure        #Public Const UN_INHGPERMB = 0.02953        'inhg/mb    atmosphereic pressure        #Public Const UN_MILESPERKILOMETER = 0.6214 'mi/km      decayfactor        self.sqft_per_hectare = 107636.  #size of all water (ponds and wetlands) and fields (terrestrial) in square feet (user can modify width only)        self.acres_per_hectare = 2.471        self.sqft_per_acre = 43560.        self.cm2_per_ft2 = 929.03        self.gms_per_lb = 453.592        self.mg_per_gram = 1.e3        self.ng_per_gram = 1.e9        self.liters_per_ft3 = 28.3168        return